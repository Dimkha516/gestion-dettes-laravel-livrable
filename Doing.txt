--- CHANGEMENT api par wane                           ==================: OK

--- TEST ACCES ROUTE PAR AUTHENTIFICATION             ==================: OK

--- FILTRES ALL CLIENT:
    -- UN OU PLUSIEURS TÉLÉPHONES                     ==================: OK
    -- SURNOM: A-Z et Z-A                             ==================: 
    -- CLIENT AVEC COMPTE => INCLUDE                  ==================: 

--- GET CLIENT(ID):
    -- CLIENT AVEC COMPTE => INCLUDE                  ==================:

--- POST CLIENT:
    -- SI OBJET USER VIDE => CREATION SANS COMPTE     ==================:
    -- SI OBJET USER NON VIDE => CREATION AVEC COMPTE ==================:

    "pseudo": "mido",
    "email": "mido@gmail.com",
    "password": "Success@123"

user vers client: has
client: belongsto





------------CONTROLLERS: AJOUTER LES VÉRIFICATIONS AVANT LA RESPONSE DE SUCCES:



http://localhost:3000/swagger/index.html

--------------- A FAIRE:

    ---- MODEL USER:
 -- stocker les informations de l'utilisateur dans le token
    
    ---- MODEL CLIENT:
 -- Définir la méthode filtre par téléphone dans un scope local.
 -- Créer un service uploadService sous forme de facade qui est chargé de l'upload des images.     
 -- En retournant le client, l'image est chargée en base64.
 -- Ajouter un client:
    --- une photo de type png, jpeg ou svg avec une taille maxe de 40 ko.
    --- générer une carte de fidélité avec un code QR. 
    

    ---- MODEL ARTICLE:
 -- Définir la méthode filtre par libellé du modèle Article dans un scope local.


AJOUT COACH:
                        --- la gestion des exceptions personnalisées:
1) définir les exceptions personnalsées sur les services et les repositories

                        --- la gestion des exceptions personnalisées:

2) La gestion de l'image: Stocker dans le cloud (en stockant l'url du cloud dans la BD) et/ou en base64


validaations dossier request:
middleware qui gère les responses:


Le upload de la photo doit être géré par une fonction apart.
job et listener pour gérer l'asynchrone.
Un endpoint qui sort les clients sans images(c'est à dire qui ont leur images en local).
Ensuite créer un job qui fait une relance. Cette relance sera ratachée à une commande.


----------------------------- VERSION SANS EVENTS;LISTENER;JOBS;OBSERVER:
    
    ---------------CLIENT CONTROLLER:
     public function storeWithAccount(StoreClientRequest $clientRequest, StoreUserRequest $userRequest): JsonResponse
    {
        try {
            // Valider les données du client et de l'utilisateur
            $validatedClientData = $clientRequest->validate([
                'surname' => 'required|string|max:255',
                'telephone' => 'required|string|max:20',
                'adresse' => 'nullable|string|max:255',
                'photo' => 'nullable|file|mimes:jpeg,png,svg|max:40960', // 40 KB
            ]);  

            $validatedUserData = $userRequest->validate([
                'pseudo' => 'required|string|max:255',
                'email' => 'required|email|max:255|unique:users,email',
                'password' => 'required|string|min:8|confirmed',
            ]);

            $photo = $clientRequest->file('photo'); // Récupérer la photo du formulaire
            
            // // Passer les données validées et le fichier photo au service:
            // $result = $this->clientService->createClientWithAccount(
            //     $clientRequest->$validatedClientData,
            //     $userRequest->$validatedUserData,
            //     $photo
            // );
            // Passer les données validées et le fichier photo au service:
            $result = $this->clientService->createClientWithAccount(
                $clientRequest->validated(),
                $userRequest->validated(),
                $photo
            );
           

            return response()->json([
                'success' => true,
                'message' => 'Client et compte utilisateur enregistrés avec succès',
                'data' => $result
            ], 200);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Erreur lors de l\'enregistrement du client et de l\'utilisateur',
                'error' => $e->getMessage()
            ], 500); // 500 Internal Server Error
        }

    }
    ---------------CLIENT SERVICE:
    public function createClientWithAccount(array $clientData, array $userData, $photo)
    {
        // $testUpload = Cloudinary::upload('path_to_a_test_image.jpg');
        // dd($testUpload->getSecurePath());
        \DB::beginTransaction();

        try {

            // Gérer l'upload de la photo si elle est fournie:
            if (request()->hasFile('photo')) {
                $photo = request()->file('photo');
                
                $uploadResult = $this->cloudinary->uploadApi()->upload($photo->getRealPath(), [
                    'folder' => 'clients_photos',
                    'public_id' => $clientData['surname'] . '_' . time(),
                    'resource_type' => 'image'
                ]);
                $clientData['photo'] = $uploadResult['secure_url'];
            } 
            else {
                $clientData['photo'] = 'https://res.cloudinary.com/dytchfsin/image/upload/v1725465088/xcb8pgm42qc6vkzgwnvd.png';
            }

            // Débogage des données avant insertion
            // dd($clientData, $userData);

            // Créer le client et l'utilisateur:
            $client = $this->clientRepo->createClient($clientData);
            $user = $this->clientRepo->createUser([
                'pseudo' => $userData['pseudo'],
                'email' => $userData['email'],
                'password' => Hash::make($userData['password']),
                'role' => 'client',
                // 'photo' => $userData['photo']
            ]);

            // Lier le client à l'utilisateur
            $this->clientRepo->updateClientWithUser($client, $user->id);


            // Générer le code QR pour le client
            $qrContent = 'Client ID: ' . $client->id . ', Nom: ' . $client->surname;

            // Utiliser le Builder pour générer le QR code
            $qrCode = Builder::create()
                ->writer(new PngWriter())
                ->data($qrContent)
                ->encoding(new Encoding('UTF-8'))
                ->size(300)
                ->build();

            // Chemin pour enregistrer le QR code
            $qrPath = 'qrcodes/clients/' . $client->surname . '_' . $client->id . '.png';
            Storage::disk('local')->put($qrPath, $qrCode->getString());

            // Générer la carte de fidélité en PDF
            $pdf = \Barryvdh\DomPDF\Facade\Pdf::loadView('fidelite_card', [
                'pseudo' => $user->pseudo,
                'email' => $user->email,
                'qrCodePath' => $qrPath,
                'photoUrl' => $clientData['photo']
            ]);

            // Sauvegarder le PDF dans un dossier
            $pdfPath = 'fidelite_cards' . $client->surname . '_' . $client->id . '.pdf';
            Storage::disk('local')->put($pdfPath, $pdf->output());

            // Mail::to($user->email)->send(new ClientFidelityCardMail($client, $user, $pdfPath));

            \DB::commit();

            return [
                'client' => $client,
                'user' => $user,
                'qr_code_path' => $qrPath,
                'fidelite_card_path' => $pdfPath
            ];
        } catch (\Exception $e) {
            \DB::rollBack();
            throw $e;
        }
    }

    ---------------CLIENT REPOSITORY:
    class ClientRepository
{
    public function createClient(array $clientData)
    {
        return Client::create($clientData);
    }

    public function createUser(array $userData)
    {
        return User::create($userData);
    }

    public function updateClientWithUser(Client $client, int $userId)
    {
        $client->user_id = $userId;
        $client->save();
    }
}

------------------------------------------------------- GESTION CREATION CLIENT ET UTILISATEUR:
1: Créer des événements et des écouteurs :
    --- Un événement pour signaler la création d'un client et d'un utilisateur.

    --- Un écouteur pour gérer l'envoi de l'email avec le PDF et le QR code.

2: Créer des jobs :

 --- Un job pour gérer l'upload de la photo sur Cloudinary.
 --- Un job pour générer le QR code.
 --- Un job pour générer le PDF.
 --- Un job pour envoyer l'email.

3: Utiliser des observateurs :

--- Un observateur pour déclencher les jobs après la création du client et de l'utilisateur.


    ---------- LES EVENEMENTS:
*** ClientCreated


     ---- LISTENER:
*** SendClientFidelityCardMail 

    ---- JOBS:
*** UploadPhotoToCloudinary
*** GenerateQRCode
*** GeneratePDF

    ---- OBSERVERS:
*** ClientObserver

    ---- AppServiceProvider
*** Enregistrer l'observateur


------------------------------------------------------- GESTION NOTIFICATION DETTE:

1. Création de la notification par email:
    *** php artisan make:notification RappelDetteNotification

2. Création du job pour l'envoi des emails de rappel
    *** php artisan make:job RappelDetteJob

3. Planification de la tâche avec Laravel Scheduler
    *** Modification dans app/Console/Kernel.php :

4. Test en temps réel
    *** composer dump-autoload
    *** php artisan tinker
    *** App\Jobs\RappelDetteJob::dispatch(); => Dans le terminal tinker
    *** RappelDetteJob::dispatch();  => Dans le terminal tinker 


-------------------------- ARCHIVAGE DETTE SOLDÉES:-----------------------------
1) Installation et config mongodb

2) Création model pour les dettes archivées (non nécessaire si on utilise Cluster)

3) Création JOB pour l'Archivage

4) Programmer l'archivage dans app/Console/Kernel.php

5) Teste manuel de l'archivage sur Tinker: ArchivageDetteJob::dispatch();


-------------------------- NOTIFICATION SMS RAPPEL DETTE :-----------------------------
1) Inscription TWILIO

2) Configuration TWILIO: .env ; /config/services.php

3) Services/TwilioService.php

4) RappelDetteSmsJob.php

5) RappelDetteSmsJobNotification

6) Kernel



-------------------- RÉSOLUTION ERREUR PUSH ------------------------
 *** bfg --delete-files firebase_credentials.json
 *** git reflog expire --expire=now --all && git gc --prune=now --aggressive    



AFTER JUMAH: TESTER LE MESSAGE SUR LE SERVICE QUI MARCHE:
    CODE TINKER:
    > $smsService = app(App\Services\SmsService::class);
= App\Services\SmsService {#5166}

> $number = '+221781114327';
= "+221781114327"

> $message = "Salut";
= "Salut"

> $response = $smsService->sendSms($number, $message);
= "{"messages":[{"messageId":"4262327350224335960032","status":{"description":"Message sent to next instance","groupId":1,"groupName":"PENDING","id":26,"name":"PENDING_ACCEPTED"},"to":"+221781114327"}]}"

> echo $response;
{"messages":[{"messageId":"4262327350224335960032","status":{"description":"Message sent to next instance","groupId":1,"groupName":"PENDING","id":26,"name":"PENDING_ACCEPTED"},"to":"+221781114327"}]}⏎
> $smsService = app(App\Services\SmsService::class);
= App\Services\SmsService {#5180}





 $user = Auth::user();
        if (!$user) {
            return response()->json([
                'message' => "Connectez vous d'abord."
            ], 403);
        }
        if (!in_array($user->role, ['admin'])) {
            return response()->json([
                'message' => 'Autorisation rejettée. Seuls les admins peuvent lister les utilisateurs.'
            ], 403);
        }


Démarrer un worker : php artisan queue:work

Démarrer un worker et le faire fonctionner en boucle (meilleur pour la production): php artisan queue:work --daemon

Lancer le worker en mode debug (voir les erreurs): php artisan queue:work --tries=3

Lancer le planificateur manuellement (pour test) si QUEUE_CONNECTION=sync dans .env: php artisan schedule:run



---------------------------TRAITEMENT MESSAGERIE RAPPEL DETTE--------------------

1) Installation et configuration TWILIO et INFOBIP

2) SmsServiceInterface

3) TwilioService

4) InfoBipService

5) RappelDetteSmsJob ==> Lecture du fichier .env pour choisir le service à exécuter

--------------------------------- ARCHIVAGE MONGO & FIREBASE:

--- App\Services\ArchivageServiceInterface
--- App\Services\FirebaseArchiveService
--- App\Services\MongoArchiveService
--- App\Services\ArchivageFactory
--- App\Job\ArchivageDetteJob 

---------------------------- LISTER LES DETTES ARCHIVÉES PAR MONGO ET FIRE:

--- App\Repositories\
--- App\Repositories\MongoDetteArchivageService.php
--- App\Repositories\FirebaseDetteArchivageService.php
--- App\Repositories\DetteFactory
--- App\Services\DetteService


---------------------------- DEMANDE DE DETTE CLIENT:

--- App\Http\Requests\StoreDebtRequest => Validation données de la demande dette.

--- App\Notifications\DebtRequestNotification => Le contenu de la notification. 

--- App\Services\DebtRequestService => Gère l'authentification de l'utilisateur et traite les données de la demande.

--- App\Http\Controllers\DebtRequestController => Enregistre la demande de dette et déclanche le job Notification

--- App\Jobs\SendDebtRequestNotification =>  Envoie la notification aux boutiquiers 


Custum Eloquent class
Builder
Cast
























----------------------------ARCHIVAGE MONGO FONCTIONNELLE:
<?php

namespace App\Jobs;

use App\Models\Dette;
use DB;
use Kreait\Firebase\Factory;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;


class ArchivageDetteJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    /**
     * Create a new job instance.
     */
    public function __construct()
    { 
        //
    }

    /**
     * Execute the job.
     */
    public function handle(): void
    {
        
        // Log::info('Bonjour');

        //----------------------- CONNEXION MONGO_DB-----------
        // Récupérer les dettes soldées (montant == paiement) à partir de MySQL
        $dettesSoldees = DB::connection('mysql')->table('dettes')
            ->whereColumn('montant', '=', 'montant_paiement')
            ->get();

        // Pour chaque dette, l'archiver dans MongoDB
        foreach ($dettesSoldees as $dette) {
            DB::connection('mongodb')->collection('archived_debts')->insert([
                'dette_id' => $dette->id,
                "client_id" => $dette->client_id,
                'montant' => $dette->montant,
                'montant_paiement' => $dette->montant_paiement,
                'date' => $dette->created_at,
                'archived_at' => now(),
            ]);

            // Supprimer la dette de MySQL après archivage
            DB::connection('mysql')->table('dettes')->where('id', $dette->id)->delete();
        }

        Log::info('Dettes Soldées Du Jour Archivées avec succès !');
    } 
}


